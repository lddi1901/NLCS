// üéØ L·∫•y ph·∫ßn t·ª≠ canvas v√† context
const canvas = document.getElementById("graphCanvas");
const ctx = canvas.getContext("2d");
const modeSelector = document.getElementById("modeSelector");
const Swal = require("sweetalert2");

let nodes = []; // Danh s√°ch ƒë·ªânh
let edges = []; // Danh s√°ch c·∫°nh
let isDraggingNode = false;
let isDrawingEdge = false;
let selectedNode = null;
let tempEdge = null;

const NODE_RADIUS = 25;

canvas.addEventListener("mousedown", async (event) => {
    const x = event.offsetX;
    const y = event.offsetY;
    let clickedNode = getNodeAt(x, y);
    let clickedEdge = getEdgeAt(x, y);

    if (getCurrentMode() === "drawNode") {
        if (clickedNode) {
            selectedNode = clickedNode;
            isDraggingNode = true;
        } else {
            if (getCurrentMode() === "drawNode") {
    if (clickedNode) {
        selectedNode = clickedNode;
        isDraggingNode = true;
    } else {
        const { value: nodeName } = await Swal.fire({
            title: "Nh·∫≠p t√™n ƒë·ªânh",
            input: "text",
            inputAttributes: { maxlength: 2 },
            showCancelButton: true,
            confirmButtonText: "OK",
            cancelButtonText: "H·ªßy",
            preConfirm: (name) => {
                if (!/^(?:[A-Z]|[1-9][0-9]?)$/.test(name)) {
                    Swal.showValidationMessage("Ch·ªâ ch·∫•p nh·∫≠n ch·ªØ c√°i A-Z ho·∫∑c s·ªë t·ª´ 1-99!");
                }
                return name;
            }
        });

        if (nodeName) {
            nodes.push({ x, y, id: nodeName });
            drawGraph();
        }
    }
}

            drawGraph();
        }
    }

    if (getCurrentMode() === "drawEdge") {
        if (clickedNode) {
            selectedNode = clickedNode;
            isDrawingEdge = true;
            tempEdge = { x1: x, y1: y, x2: x, y2: y };
        }
    }

    if (getCurrentMode()=== "deleteNode" && clickedNode) {
        deleteNode(clickedNode);
        drawGraph();
    }

   if (getCurrentMode() === "deleteEdge" && clickedEdge) {
        deleteEdge(clickedEdge);
        drawGraph();
    }

    // üìå Ch·ªânh s·ª≠a tr·ªçng s·ªë c·∫°nh
    if (getCurrentMode() === "editWeight" && clickedEdge) {
        const { value: newWeight } = await Swal.fire({
            title: "Ch·ªânh s·ª≠a tr·ªçng s·ªë",
            input: "number",
            inputAttributes: { min: "1" },
            inputValue: clickedEdge.weight, // Hi·ªÉn th·ªã tr·ªçng s·ªë hi·ªán t·∫°i
            showCancelButton: true,
            confirmButtonText: "C·∫≠p nh·∫≠t",
            cancelButtonText: "H·ªßy"
        });

        if (newWeight) {
            clickedEdge.weight = parseInt(newWeight); // C·∫≠p nh·∫≠t tr·ªçng s·ªë m·ªõi
            drawGraph();
        }
    }
});

// üìå S·ª± ki·ªán mousemove
canvas.addEventListener("mousemove", (event) => {
    const x = event.offsetX;
    const y = event.offsetY;

    if (isDraggingNode && selectedNode) {
        selectedNode.x = x;
        selectedNode.y = y;
        drawGraph();
    }

    if (isDrawingEdge && selectedNode) {
        tempEdge = { x1: selectedNode.x, y1: selectedNode.y, x2: x, y2: y };
        drawGraph();
    }
});

// üìå S·ª± ki·ªán mouseup
canvas.addEventListener("mouseup", async (event) => {
    const x = event.offsetX;
    const y = event.offsetY;

    if (isDraggingNode) {
        isDraggingNode = false;
        selectedNode = null;
    }

    if (isDrawingEdge) {
        let targetNode = getNodeAt(x, y);
        if (targetNode && targetNode !== selectedNode) {
            const { value: weight } = await Swal.fire({
                title: "Nh·∫≠p tr·ªçng s·ªë c·∫°nh",
                input: "number",
                inputAttributes: { min: "1" },
                showCancelButton: true,
                confirmButtonText: "OK",
                cancelButtonText: "H·ªßy"
            });

            if (weight) {
                addEdge(selectedNode, targetNode, parseInt(weight));
            }
        }
        isDrawingEdge = false;
        selectedNode = null;
        tempEdge = null;
        drawGraph();
    }
});

// üìå H√†m l·∫•y ƒë·ªânh t·∫°i v·ªã tr√≠ click
function getNodeAt(x, y) {
    return nodes.find(node => Math.hypot(node.x - x, node.y - y) < NODE_RADIUS);
}

// üìå H√†m ki·ªÉm tra ƒëi·ªÉm c√≥ n·∫±m tr√™n c·∫°nh kh√¥ng (ch√≠nh x√°c h∆°n)
function isPointOnEdge(x, y, edge) {
    const { start, end, curveOffset } = edge;

    // T√≠nh to√°n ƒëi·ªÉm ƒëi·ªÅu khi·ªÉn c·ªßa ƒë∆∞·ªùng cong
    const midX = (start.x + end.x) / 2;
    const midY = (start.y + end.y) / 2;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const normalX = -dy;
    const normalY = dx;
    const length = Math.hypot(normalX, normalY);
    const curveX = midX + (normalX / length) * curveOffset;
    const curveY = midY + (normalY / length) * curveOffset;

    // Ki·ªÉm tra kho·∫£ng c√°ch t·ª´ ƒëi·ªÉm click ƒë·∫øn ƒë∆∞·ªùng cong
    let t = 0;
    while (t <= 1) {
        let px = (1 - t) * (1 - t) * start.x + 2 * (1 - t) * t * curveX + t * t * end.x;
        let py = (1 - t) * (1 - t) * start.y + 2 * (1 - t) * t * curveY + t * t * end.y;
        if (Math.hypot(px - x, py - y) < 6) {
            return true; // N·∫øu kho·∫£ng c√°ch g·∫ßn ƒë∆∞·ªùng cong th√¨ ch·ªçn c·∫°nh n√†y
        }
        t += 0.02; // Ki·ªÉm tra t·ª´ng b∆∞·ªõc nh·ªè tr√™n ƒë∆∞·ªùng cong
    }
    return false;
}

// üìå H√†m l·∫•y c·∫°nh t·∫°i v·ªã tr√≠ click
function getEdgeAt(x, y) {
    return edges.find(edge => isPointOnEdge(x, y, edge));
}

// üìå H√†m th√™m c·∫°nh
function addEdge(start, end, weight) {
    let existingEdges = edges.filter(edge =>
        (edge.start === start && edge.end === end) || (edge.start === end && edge.end === start)
    );

    let curveOffset = existingEdges.length > 0 ? (existingEdges.length + 1) * 35 * (existingEdges.length % 2 === 0 ? 1 : -1) : 0;

    edges.push({ start, end, weight, curveOffset });

    drawGraph();
}

// üìå H√†m x√≥a ƒë·ªânh
function deleteNode(node) {
    edges = edges.filter(edge => edge.start !== node && edge.end !== node);
    nodes = nodes.filter(n => n !== node);
}

// üìå H√†m x√≥a c·∫°nh
function deleteEdge(edge) {
    edges = edges.filter(e => e !== edge);

    let relatedEdges = edges.filter(e =>
        (e.start === edge.start && e.end === edge.end) ||
        (e.start === edge.end && e.end === edge.start)
    );

    relatedEdges.forEach((e, index) => {
        e.curveOffset = (index + 1) * 35 * (index % 2 === 0 ? 1 : -1);
    });

    drawGraph();
}

// üìå H√†m v·∫Ω l·∫°i ƒë·ªì th·ªã
function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    edges.forEach(drawEdge);
    nodes.forEach(drawNode);

    if (tempEdge) {
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(tempEdge.x1, tempEdge.y1);
        ctx.lineTo(tempEdge.x2, tempEdge.y2);
        ctx.strokeStyle = "gray";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.setLineDash([]);
    }
}

// üìå H√†m v·∫Ω ƒë·ªânh
function drawNode(node) {
    ctx.beginPath();
    ctx.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = "white";
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "black";
    ctx.font = "14px Arial";
    ctx.fillText(node.id, node.x - 5, node.y + 5);
}

// üìå H√†m v·∫Ω c·∫°nh cong
function drawEdge(edge) {
    ctx.beginPath();

    const { start, end, weight, curveOffset } = edge;
    const midX = (start.x + end.x) / 2;
    const midY = (start.y + end.y) / 2;
    const dx = end.x - start.x;
    const dy = end.y - start.y;
    const normalX = -dy;
    const normalY = dx;
    const length = Math.hypot(normalX, normalY);
    const curveX = midX + (normalX / length) * curveOffset;
    const curveY = midY + (normalY / length) * curveOffset;

    ctx.moveTo(start.x, start.y);
    ctx.quadraticCurveTo(curveX, curveY, end.x, end.y);
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "red";
    ctx.font = "bold 14px Arial";
    ctx.fillText(weight, curveX, curveY);
}
document.addEventListener("DOMContentLoaded", () => {
    const resetButton = document.getElementById("resetGraph");

    if (resetButton) {
        resetButton.addEventListener("click", () => {
            nodes = [];
            edges = [];
            drawGraph();
        });
    }
});


// üìå H√†m nh·∫≠p file
function importGraph() {
    const fileInput = document.getElementById("fileInput");
    fileInput.click();

    fileInput.onchange = (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            const content = e.target.result;
            parseGraphData(content);
            fileInput.value = ""; // Reset ƒë·ªÉ c√≥ th·ªÉ nh·∫≠p l·∫°i c√πng file
        };
        reader.readAsText(file);
    };
}


function parseGraphData(content) {
    nodes = [];
    edges = [];
    const nodeMap = new Map(); 

    const lines = content.split("\n").map(line => line.trim()).filter(line => line);

    lines.forEach(line => {
        const parts = line.split(" ").map(Number);
        if (parts.length !== 3 || isNaN(parts[0]) || isNaN(parts[1]) || isNaN(parts[2])) {
            console.error("L·ªói d·ªØ li·ªáu d√≤ng:", line);
            return;
        }
        const [startId, endId, weight] = parts;

        if (!nodeMap.has(startId)) {
            nodeMap.set(startId, { id: startId, x: Math.random() * 600 + 50, y: Math.random() * 400 + 50 });
        }
        if (!nodeMap.has(endId)) {
            nodeMap.set(endId, { id: endId, x: Math.random() * 600 + 50, y: Math.random() * 400 + 50 });
        }

        edges.push({ 
            start: nodeMap.get(startId), 
            end: nodeMap.get(endId), 
            weight, 
            curveOffset: 0 
        });
    });

    nodes = Array.from(nodeMap.values());
    drawGraph();
}


// üìå H√†m xu·∫•t file
function exportGraph() {
    let content = "";
    edges.forEach(edge => {
        content += `${edge.start.id} ${edge.end.id} ${edge.weight}\n`;
    });

    const blob = new Blob([content], { type: "text/plain" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "graph.txt";
    a.click();
}
canvas.addEventListener("mousedown", (event) => {
    const mode = getCurrentMode();
    
    if (mode === "drawNode") {
        canvas.style.cursor = "crosshair";
    } else if (mode === "drawEdge") {
        canvas.style.cursor = "pointer";
    } else if (mode === "deleteNode" || mode === "deleteEdge") {
        canvas.style.cursor = "not-allowed";
    } else {
        canvas.style.cursor = "default";
    }

    // ƒê·∫£m b·∫£o c·∫≠p nh·∫≠t l·∫°i font ch·ªØ khi v·∫Ω l√™n canvas
    const ctx = canvas.getContext("2d");
    ctx.font = "16px Arial"; // ƒê·∫£m b·∫£o font ch·ªØ nh·∫•t qu√°n
});

canvas.addEventListener("mouseup", () => {
    canvas.style.cursor = "default";
});

document.querySelectorAll(".mode-btn").forEach(button => {
    button.addEventListener("click", () => {
        document.querySelectorAll(".mode-btn").forEach(btn => btn.classList.remove("active"));
        button.classList.add("active");
        currentMode = button.getAttribute("data-mode");
        document.getElementById("modeIndicator").innerText = `Ch·∫ø ƒë·ªô: ${button.innerText}`;
    });
});
